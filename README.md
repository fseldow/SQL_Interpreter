# cs4321_p1
## Prerequisite
- Maven v.10.0  
- Oracle JDK 1.8  
## Installation
- Build

    ```
    mvn package
    ```
    The output **.jar** will be built in **/Target**  
    **Bug**: The jar generated by maven cannot be run due to the system scope dependency. Please adjust it to compile or use ```mvn install``` to install the package in maven's dependencies management folder.
- IDE

    If you want to use Eclipse, try the command below:  
    ```
    mvn eclipse:eclipse
    ```
## Implement
-  **Top-level class** is ```com.sql.interpreter.App```
-  The runnable jar could be run in cmd 

    ```java -jar cs4321_p3.jar $<interpreter_config_file>```
## Details
### Selection Pushing
Pushing selection is implemented using the info generated by UnionFind. Selections are pushed in the LogicalPlanBuilder class. After the creation of a logical ScanOperator, all the attributes in the UnionFind list would be traversed. For each attribute that both belongs to the schema of the scanOperator and also have its constraints, the attribute would be added to a Map. Finally, if the Map is not null, a SelectOperator would be created using all the attributes and constraints in the Map.
 
#### Union Find
The UnionFind class contains two important methods: ```find``` and ```union```. It unions elements together creating separate sets. If two elements in two different sets union, these two sets will merge together. All the elements in a set have the same attributes.
1. ```find``` takes in a column and returns the corresponding Constraints object. It finds the root constraints according to a father map of union find class. Once the root is found, update the roots of all the visited nodes to the same Constraints object.
2. ```union``` takes two columns and merge them together. The corresponding two sets will be merged after this when the ```find``` method is used on these columns.  

### Query Plan Print
#### Logical Query Plan Print
The logical query plan is printed by traversing all the logical operators in the plan tree in preorder using visitor pattern implemented as PhysicalOperatorVisitor class. In each visit function in the PhysicalOperatorVisitor class, information of the input argument operator is first printed, then the children/child of the operator will accept this visitor in order. The union find information will be printed with the help of union find getOutput() method.
Possible differences from expected output:
1. No project operator if the query is "SELECT * From ....."
2. For Join operator, conditions like S.A < R.E will not create new elements in union find.
3. Order of leaves and union elements.

#### Physical Query Plan Print
The physical query plan is printed by traversing all the physical operators in the plan tree in preorder using visitor pattern implemented as PhysicalOperatorVisitor class. In each visit function in the PhysicalOperatorVisitor class, information of the input argument operator is first printed, then the children/child of the operator will accept this visitor in order.


### Join Order
```PlanBuilder.JoinOrder```  
- Considering our schema stradegy, we have to calculate the join order during the logcial plan builder, in logical operator exactly.
- The optimal order is obtained via dynamic programming. We recursively traverse the subset and record the optimal solution locally to avoid repeated computing.

### Join Implement
In my Project 2 benchmarking, I noticed that
SMJ runs much faster than BNLJ, so I implement all joins as SMJ where possible. However, SMJ does not
apply to joins that have other-than-equality comparisons or to pure cross-products, so those are
implemented using BNLJ.  
When implementing samples in the server, although BNLJ takes the lower I/Os, SMJ runs 120 times faster than BNLJ under the same block size.
