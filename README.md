# cs4321_p1
## Prerequisite
- Maven v.10.0  
- Oracle JDK 1.8  
## Installation
- Build

    ```
    mvn package
    ```
    The output **.jar** will be built in **/Target**  
    **Bug**: The jar generated by maven cannot be run due to the system scope dependency. Please adjust it to compile or use ```mvn install``` to install the package in maven's dependencies management folder.
- IDE

    If you want to use Eclipse, try the command below:  
    ```
    mvn eclipse:eclipse
    ```
## Implement
-  **Top-level class** is ```com.sql.interpreter.App```
-  The runnable jar could be run in cmd 

    ```java -jar cs4321_p3.jar $<interpreter_config_file>```
## Details
### Selection Pushing
Pushing selection is implemented using the info generated by UnionFind. Selections are pushed in the LogicalPlanBuilder class. After the creation of a logical ScanOperator, all the attributes in the UnionFind list would be traversed. For each attribute that both belongs to the schema of the scanOperator and also have its constraints, the attribute would be added to a Map. Finally, if the Map is not null, a SelectOperator would be created using all the attributes and constraints in the Map.
 
#### Union Find
The UnionFind class contains two important methods: ```find``` and ```union```. It unions elements together creating separate sets. If two elements in two different sets union, these two sets will merge together. All the elements in a set have the same attributes.
1. ```find``` takes in a column and returns the corresponding Constraints object. It finds the root constraints according to a father map of union find class. Once the root is found, update the roots of all the visited nodes to the same Constraints object.
2. ```union``` takes two columns and merge them together. The corresponding two sets will be merged after this when the ```find``` method is used on these columns.  

### Query Plan Print
#### Logical Query Plan Print
The logical query plan is printed by traversing all the logical operators in the plan tree in preorder using visitor pattern implemented as PhysicalOperatorVisitor class. In each visit function in the PhysicalOperatorVisitor class, information of the input argument operator is first printed, then the children/child of the operator will accept this visitor in order. The union find information will be printed with the help of union find getOutput() method.

#### Physical Query Plan Print
The physical query plan is printed by traversing all the physical operators in the plan tree in preorder using visitor pattern implemented as PhysicalOperatorVisitor class. In each visit function in the PhysicalOperatorVisitor class, information of the input argument operator is first printed, then the children/child of the operator will accept this visitor in order.


### Index Scan Operator
1. Where the ```lowkey``` and ```highkey``` are set  
In fact, ```lowkey``` and ```highkey``` are extracted in physical plan builder, and be parsered into the operator via constructor. The tool to extract them is ```IndexScanExpressionVisitor```, which might be detailed illustrated in ```doc\ExpressionVisitor.md``` or the related _Java doc_.  
Briefly speaking, we extract the lowKey and highKey from the select condition, with the following rules:
    - If thereis no high bound or low bound, ```highKey``` will be set ```MAX_INT``` or ```lowKey``` to be ```MIN_INT```. If both unavailable, we will not implement Index Scan Operator.
    - Since we have assumed all tuple are Integer, we let the key be the involved.   
        e.g. ```S.A < 50``` -> ```highKey = 49```
    - If there exists valid equal condition, e.g ```S.A = 50```, we will set both ```highKey``` and ```lowKey``` _50_.

2. Difference in clustered vs. unclustered  
    We will load the Index Config according to the table name and column name.  
    You can find the related code in ```operator.PhysicalIndexScanOperator.nextTuple```
    - If clustered:  
        After we get the first Rid and reset the tuple reader according to the Rid. Then we directly implement ```getNextTuple``` of the tuple reader. Read sequently until it exceeds ```highKey```.
    - If unclustered:  
        Each time we get the next Rid via ```deserializer``` and reset the tuple reader to read the tuple in the table.  
    
3. How preform the root-ro-leaf tree descent  
    The deserializer first searches for the starting node via the ```lowKey```. It works via ```btree.Deserializer.searchLeafNode``` recursively.  
    Each time it reach an index node, we will get the next node address via ``lowKey` until we reach an entry node.     
4. How decides which nodes to be deserialized   
   After we reach the first leaf node, we only need to sequently scan the node address by address. The deserialization will end until exceed ```highKey``` or meet unexpected format node (end of entry node).
### Physical Plan Builder
#### Judge whether or not the selection operator to be handled via Index
_There are four conditions to make the judgement:_  
1. The third line of ```plan_builder_config``` is set _1_
2. The child logical operator is scan operator(leaf operator).
3. We can find at least one Index Config accroding to the schema key
4. The ```highKey``` and ```lowKey``` extracted from the join condition is not ```MAX_INT``` and ```MIN_KEY``` at the same time.


## Posible Bugs:
Some tests cannot run, since the ambiguous usage of ```samples``` and ```samples-2```. But it does not affect the jar functions.